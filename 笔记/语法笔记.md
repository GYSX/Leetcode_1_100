# Java基础篇
<!-- MarkdownTOC -->

- Java 重要历史节点
- Java的优势
- Java 的特点
- 反编译
- 编程风格
- 注释
- JDK 、JRE、 JVM都是什么
- Java API 文档
- Java 中的关键字 **不允许用作标识符使用**。
- 标识符
  - 标识符规则
- 数据类型
- 变量\(可以变化的量\)
  - 变量的分类
  - 变量的声明
- 基本数据类型
  - 数值类型
    - 整数类型
    - 小数类型 （浮点数类型）
  - 字符类型
  - boolean 类型
  - 基本数据类型转换
- 运算符
  - 算数运算符
  - 位运算符
  - 赋值运算符
  - 比较运算符
  - 逻辑运算符
  - 三目运算符（ 三元运算符 ）
- 分支结构
- 循环结构
  - while
  - for 循环
  - do……while
  - 循环嵌套
  - break 和 continue
- 数组
  - 概念
  - 一维数组
    - 声明语法
    - 初始化
    - 数组中的常用概念
    - 数组的默认初始值
    - 数组的内存模型
  - N维数组
- 重点：十大经典排序
- 数组的复制
- java.util.Arrays
- 面向对象编程 （OOP）
  - 创建一个类
  - this 关键字 \(当前对象的代号\)
  - 内存分析 之 创建对象
  - 方法
    - 形参与实参
    - 方法的返回值
    - 方法的归属
    - 方法重载
    - 可变长参数
    - 参数传递机制
  - 递归的想法
  - 封装
  - Java 中的 包
  - import关键字
  - 构造
  - 继承
    - super 关键字
  - 重写\( override \)
  - 多态
    - instanceof
    - 引用强制类型转换的本质
  - static 关键字
  - 代码块
  - final 关键字
  - 密封类
  - abstract 关键字
  - 抽象类的应用\( Number类 与 包装类 \)
    - Number类
    - 包装类
      - 通用方法
      - 常用方法
        - Byte
        - Short
        - Integer
        - Long
        - Float
        - Double
        - Boolean
        - Character
    - 数字格式化 NumberFormat

<!-- /MarkdownTOC -->

## Java 重要历史节点

- Java 之父 ： *James Gosling*（詹姆斯·高斯林）
	- 1995 年 Java 发布   
	- 2004 年 JDK5发布（巨大影响）   
	- 2009年被 Oracle 收购  
	- 2014年JDK8发布（目前企业常用版本）  
	- 2018年JDK11 LTS发布（目前正在逐步替换成JDK11） 
	- 2021年发布JDK17（未来的版本，未普及）
- JDK长期支持版本
	+ JDK 8，JDK11  

## Java的优势

- （了解C的基础下）相对于 C++ 来说 简单易学
- 基于面向对象的语言
- 语法明确，类库很多，通过调用可以快速解决问题。
- 有很多机构在支持整个Java 的生态圈（有巨人顶天）  
 		```
 		- Spring（春天？）：不是公司名，是Pivotal公司下的The Spring team团队维护的项目
 		- Apache（阿帕奇）：Tomcat是他们的项目
 		- JetBrains：主打产品IntelliJ IDEA，WebStorm等
 		- Oracle：全球最大的信息管理软件及服务供应商
 		```
- Java 是 大数据、人工智能等未来发展方向的基础。（未来可期）

## Java 的特点


1. **面向对象** 	：已对象为基础；
1. **分布式**		： 一个系统可以部署在一台机器的多个JVM上（或多台机器上）
```
分布式管理工具：Spring Cloud（一系列框架的有序集合）
```
1. **健壮性** ：检查机制完备，编译阶段，运行阶段都检查
1. **安全性** :Java 安全模型基于一个可定制的“沙盒”，Java软件程序可在其中安全运行
```
1. 取消了指针:避免了指针移动造成的越界，恶意修改。
2. 异常处理机制：方法抛出异常。
3. 垃圾回收机制：内存回收由机器执行，避免人工造成的错误
4. 类型转换规则：满足规则的数据才可以转换成功。
```
1. **可移植性** ：程序执行通过java虚拟机（JVM），与机器系统无关。
1. **多线程** ：多个线程处理任务，而且还处理的很好（ **重点** ）
1. **动态性** Java本质为 **静态语言** 但具有一些动态性质  
`程序以一个个类的形式存储，编译后形成.class文件，可以在运行时加载编译期间未知的类，但降低性能（不推荐）`
1. **简单** ：单指语法简单，省略了C++ 中大量的具有争议的内容（如：指针）

## 反编译

在Java中，可以使用 `javap` 命令来执行反编译 ， 可以看到的是 虚拟机命令。此时，需要注意：以后学习虚拟机的话，可以使用该命令进行查看具体的操作。

## 编程风格
IDEA下载插件  `阿里巴巴java代码检查规约` 
一般‘行尾’风格（Kernighan风格）。
IDEA格式化快捷键：`Ctrl+Alt+L`

## 注释
- 单行注释 ：IDEA快捷键：`Ctrl+/`
  ```text
    // 单行注释 
    
  ```
- 多行注释 ：IDEA快捷键：`选中注释内容+ Ctrl+Shift+/ `
  ```text
  /* 多行
  注释  */
  ```

- Javadoc 注释: IDEA快捷键：`输入 /** 后 +Enter`
  ```text
  /**
   * java doc 注释 
   * @param  
  */
  ```
## JDK 、JRE、 JVM都是什么
- JDk ： Java 开发工具包， 其中包含了 JRE
```
(Java Develop Kit)
JDK本体也是Java程序，因此运行依赖于JRE
所以为了保持JDK的独立性与完整性
我们可以在java安装处找到两个JRE
```
- JRE ： Java 运行环境， 其中包含了 JVM
```
(Java Runtime Environment)  
JRE=虚拟机平台+虚拟机本体(JVM)
类比VM
```
- JVM ： Java 虚拟机
```
（Java Virtual Machine）
类比VM上的Ubuntu虚拟机
```

## Java API 文档
- API ： Application Programming  Interface  应用程序接口 ， 是一些预先定义的接口（如函数、HTTP接口），或指软件系统不同组成部分衔接的约定。
- Java API 文档 ： Java 内部所有的接口或类 中的方法 的说明文档！

## Java 中的关键字 **不允许用作标识符使用**。
关键字：在Java中具有一些特定意义的单词。如 int，true

保留字 ：如 goto、const ； 就是目前Java 中暂时没有使用 ，可能以后会使用，

## 标识符
标识符就是 Java 中对 变量、类、接口、枚举、记录、方法等命名的一个 字符序列 。 

字符序列 ： 由多个字符组成 的一个 序列 ；例如：Person , eat , school_name 


### 标识符规则

* Java标识符由数字，字母和下划线（\_），美元符号（$）或人民币符号（￥）组成。
* 在Java中是区分大小写的，而且还要求首位不能是数字。
* 不建议使用中文。
* 习惯上养成，只用 字母 、下划线  
* 编程风格建议使用 **驼峰式规则** 
```text
1、小驼峰式命名法（lower camel case）：
第一个单词以小写字母开始，第二个单词的首字母大写。
例如：firstName。
2、大驼峰式命名法（upper camel case）：
每一个单词的首字母都采用大写字母，
例如：FirstName，也被称为 Pascal 命名法。

在JAVA中：
类名的标识符一般用大驼峰式书写格式，
方法和变量的标识符则多用小驼峰式书写格式。

```
## 数据类型
Java 是一个 强类型语言 ， 每一个变量都有自己明确的类型 。如果类型不一样，一般不会轻易的重新赋值（需要实现目的时，依照转换规则转换）。

```
JDK1.8 之后，提出了 类型推断
 `var`关键字来声明一个变量
 这个变量的类型由Java自动推断。
```

在Java 中，只有两种数据类型 ： 基本数据类型 、 引用数据类型 。 


## 变量(可以变化的量)
1. 变量的概念：  
	* 内存中的一个存储区域
	* 该区域的数据可以在同一类型范围内不断变化
	* 变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值

2. 变量的作用：
	+ 用于在内存中保存数据
	+ 让编程人员更高效的操纵数据

3. 用变量注意：

	- Java中每个变量必须***先声明，后使用.***
	- 使用变量名来访问这块区域的数据
	- 变量的作用域：其定义所在的一对{ }内 ; 
	- 变量只有在其作用域内才有效
	- 同一个作用域内，不能定义重名的变量
	- 变量的作用域***向内延展***，{}中的{}也生效  
		故内外也不可以重名

### 变量的分类

 + 成员变量 （在类范围里定义的变量）
 	* 静态变量（static 修饰的变量）：在当前类中一直有效
 	* 实例变量 ： 在一个对象中有效 。
 + 局部变量 ： 在方法内定义的变量
 	* 形参（方法签名中定义的变量）： 在一个方法中有效
 	* 方法局部变量（在方法内定义的变量） ：在一个方法中自身的作用域中有效
 	* 代码块局部变量（在代码块中定义的变量）：
 	在一个代码块中自身的作用域中有效
 
### 变量的声明
语法规则 ：
```text
数据类型 变量名( 标识符 ) [ = 具体的值 ] ;
```
单独声明一个变量 ：
```text
var a ; 
```
声明变量并赋值 ：
```text
var a  = 0  ; 
```
声明完变量之后，连续赋值 ：   
`不允许使用 var 来连续声明变量:var a,b,c;(X) `
```text
int  a , b , c ; 
a = b = c =0;
```

## 基本数据类型
基本数据类型  ***八种***   
可以分为 ***三类*** ： 数值类型 、字符类型、boolean 类型 

### 数值类型
每一个数字类型都有自己的范围和长度限制， 不受具体的系统影响。
```text
在 Java 中，
如果声明了一个 小数（浮点数） ， 默认是 double 类型。
如果声明了一个 整数，默认是 int 类型 ， 
注意：
如果声明的数字在 byte 或 short 范围之中，
就会自动变成 byte 或 short ； 

```
#### 整数类型
* 一共有 4 个， 分别是 ： byte、short 、int 、long 

	+ byte 占用 1 Byte（字节）， 共计 8 bit（位）  
	 范围就是 ： -2^7 ~ 2^7 - 1 
	+ short 占用 2 字节， 共计 16 位   
	范围就是 ： -2^15 ~ 2^15 - 1 
	+ int 占用 4 字节， 共计 32 位  
	范围就是 ： -2^31 ~ 2^31 - 1 
	+ long 占用 8 字节， 共计 64 位   
	范围就是 ： -2^63 ~ 2^63 - 1 
```text
整数类型 最高位 是 符号位 有效位是占位数-1；
正数减一	是因为包含 0 ；
```
在声明整数的时候，可以使用 不用的进制来声明：二进制、八进制、十进制、十六进制。

为了防止 long 类型的数据 与 int 类型的数据 混淆， 所以在 long 类型数据的 后边，加上了 `L` 或 `l（易与1搞混）` 

#### 小数类型 （浮点数类型）
```
直接使用一个具体的小数，或科学计数法赋值
采用IEEE754标准存储
```

- float ：单精度浮点数  
有效位数8位 ，占用4个字节  
在声明的时候，需要在值后边加上指定的符号 `F` 或 `f` ;  
`因为小数默认为double类型`
- double : 双精度浮点数  
有效位数16位 ，占用8个字节

在进行计算的时候， 不够准确。
```text
		float a=  1.00000000001E9F;
  		float b=  1E9F;
        System.out.println(a+b);
```
```text
		结果=2.0E9
```
### 字符类型
***char*** , 占用空间 2 字节 。
```text
char a = 'a';
```

Java 中采用 Unicode 编码，可以存放一个字符（字母、汉字、符号） ; 可以在 char 类型中，使用 unicode 形式的 字符。

char 类型中，允许使用 转义字符 。形式: `\英文字母或特殊符号` ;  
常见的 ：`\n`换行 、`\t`制表 、`\\` \
### boolean 类型
***boolean*** , 表示逻辑判断的结果  
仅可以是 `true`、`false`。

***不能使用 0 和 非0 来表示 boolean 类型的值。***

注意 ： boolean 占用 1 bit ， 但是在Java 中， 都是以 字节 为单位，尽管 boolean 占用了1bit ，最终也是占用了***1Byte***。

### 基本数据类型转换

1. ***自动类型转换*** ：   
容量小的类型会自动转换成容量大的数据类型
  	+ 特殊情况 ： `char` 类型在 进行运算的时候， 会转换成 `int` 
  	+ `byte` , `short` , `char` 之间不会相互转换，他们三者在计算时首先转换为`int`类型。
  	+ 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。  
2. ***强制类型转换*** ：   
自动类型转换的逆过程  
将容量大的数据类型转换为容量小的数据类型。  
使用时要加上强制转换符：`(需要的类型)`  
可能造成精度降低或溢出。

## 运算符
### 算数运算符
```text
+ - * / % ++ -- 
```

`-` 如果放在数字之前，那么就表示是一个负数符号
### 位运算符
```text
>> :	右移
<< ： 	左移 
>>> ： 	无符号右移
^	（异或） 
~	（取反） 
&	（位与） 
|	（位或） 
```

### 赋值运算符
`= ` 赋值运算符 ；  
从右向左 进行计算。  
例如：`a = 100 ; ` 

可以和其他运算符组合使用 ：
```text
      byte i = 100 ; 
      i += 100 ; 	// i = i + 100 ; 
      i -= 100 ; 	// i = i - 100 ; 
      i *= 100 ; 	// i = i * 100 ; 
      i /= 100 ; 	// i = i / 100 ; 
      i %= 100 ; 	// i = i % 100 ; 
      i &= 100 ; 	// i = i & 100 ; 
      i |= 100 ; 	// i = i | 100 ; 
      i ^= 100 ; 	// i = i ^ 100 ; 
      i >>= 100 ; 	// i = i >> 100 ; 
      i >>>= 100 ; 	// i = i >>> 100 ; 
      i <<= 100 ; 	// i = i << 100 ; 
```

### 比较运算符
```text
> < >= <= != == 
比较运算符 返回的结果是 boolean 类型的结果 。
```   

1. 如果比较的是 数值类型 ， 如果数据类型 不一样 ，  
	只要值相等，就返回 true 。
2. 如果比较的是 引用数据类型， 必须指向同一个对象 ，   
	才返回true 。  
	`因为引用数据类型的值是地址值`
3. 如果两个引用对象直接使用`==`
	1. 如果 两个引用对象 不`同源` ，则***编译错误***。 
	2. 如果 两个引用对象 `同源` ， 则可以使用 == 比较   
	`只能比较两个变量是否指向同一内存`
4. 比较两个引用对象的值要调用`equals()`方法
### 逻辑运算符
```text
&& || ! 
```
逻辑运算符  
操作的是 boolean 类型的值  
结果返回的是 boolean 类型的值 

- `&&` (逻辑与) ：   
	都是true是 true , 有一个是 false 结果就是 false ；
	```text
	注意： 
	如果第一个值是true ，继续向后判断；  
	如果第一个值是false，直接返回false,放弃后续判断
	```
- `||` (逻辑或) :   
	有真（true）就是真（true）  
	```text
	注意： 
	如果第一个值是false ，继续向后判断；  
	如果第一个值是true ，直接返回true,放弃后续判断
	```
- `!` (逻辑非) : 取反 ，true 取反就是 false 

### 三目运算符（ 三元运算符 ）
语法是：
```text
boolean类型 ? 表达式1 : 表达式2
 (a > b) ? a : b ;
```
boolean 类型是true ，运行表达式1 ；   
boolean 类型是 false ， 则运行表达式2 。

## 分支结构
	
1. ***if …… else …… ***   
	
	```text
	if (boolean类型) {
		
	}else{
	
	}
	```  

  -  (boolean类型值的产出有：方法、逻辑运算符、比较运算符 )  
  -  Java 16 引入了一个对于 instanceof 的模式匹配  
  ```text
  if (A instanceof String s) {
    {代码块1}
	}
	//判断A是否为String，是以s接收再使用s
  ```
 
2. ***switch …… case ***  
	```text
	switch(var){
		case (value_1) ： break;
		...
		case (value_n) ： break;
		default : break;
	}
	```  

  - 如果case 后边不加上 break   
   从匹配到的case之后到遇到一个break为止的所有的代码都会执行  
   ```text
   case (value_1)：{代码块1} 
   case (value_2)：{代码块2} break;
   case (value_3)：{代码块3} break;
   //匹配到value_1执行{代码块1}和{代码块2}
   //匹配到value_2执行{代码块2}
   //匹配到value_1执行{代码块3}
   ```
  - switch 中 可以有 default ， 作用是 如果没有匹配的内容，将执行 default 中的内容 ( 必须写，并在最后)
  
  - switch 括号中可以传入的类型是 ：  
  	byte、short、char 、int 、枚举、String   
  	包装类（Byte、Short 、Integer、Character）
  - case 语句中的 值 一定是 ***常量***，不能是 变量或 表达式 ;
- ***分支可以相互嵌套*** 
- JDK17 新增了 switch 的 preview 版本 。
```text
//switch 语句实现类型模式匹配:
//判断A的类型并接收
	switch (A) {
        case Integer i -> String.format("int %d", i);
        case Long l    -> String.format("long %d", l);
        case Double d  -> String.format("double %f", d);
        case String s  -> String.format("String %s", s);
        default        -> o.toString();
    };
    //不写break也不会继续执行
```

## 循环结构
循环结构 ： 在满足一定条件的情况下， 反复 执行某些代码

循环四要素 ：  

1. 初始条件
2. 判定条件 
3. 迭代（步进）部分 : 有增加或减少 （ 有变化 ）
4. 循环体 ： 被 反复执行的代码 


### while
语法格式 ：
```text
1初始化部分
while( 2循环条件部分 ){
  3循环体部分;
  4迭代部分; 
  // 3、4 的位置可以调换
}
```
其中 循环条件部分 中的取值 boolean 类型的值 ； 切记：不要忘记 迭代部分 与 循环的判定条件之间的关系 ， 一定要有一个终止条件。

### for 循环
最常用的循环； while 与 for 可以相互完成替代。
语法结构：
```text
for ( 1初始化部分 ; 2循环条件部分 ; 4迭代部分 )｛
	3循环体部分;
｝
```

### do……while
while的变体  
语法结构：
```text
1初始化部分;
do{
  3循环体部分;
  4迭代部分;
}while( 2循环条件部分 );
```  

- 注：会不管判断条件先进行一次`循环体部分`和`迭代部分`;

### 循环嵌套
就是循环中可以再次放入一个循环；  

- 注意：一般不会有三层以上的循环 ；  
如果超过三层，性能会下降！

### break 和 continue

- break : 表示终止的意思 ，在循环结构中表示终止最近包含break 的循环 
- continue ： 只能使用在循环结构中；用于跳过continue语句之后循环语句块的执行，进入下一次循环  
`注：如果是while或do.while循环可能跳过迭代部分，for不会`  

说明：  

- break只能用于switch语句和循环语句中。
- continue 只能用于循环语句中。
- 二者功能类似，但continue是终止本次循环，break是终止本层循环。
- break、continue直接向后不能有其他的语句，因为将造成不可达语句
```text
while(ture){
	if (flag) {
		break;||continue;
		/*不可达区域*/
	}
	/*可达区域*/
}
```
- 很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条 语句上，然后执行它。  
***Java中不允许***  
break和continue是不同于goto的，要按规则跳，不能随意跳。


## 数组

### 概念
数组(Array)，是多个**相同类型数据**按一定顺序排列 的集合，并使用**一个名字命名**，并通过**编号**的方式 对这些数据进行统一管理。

数组是一个 **引用数据类型** 。但是数组中的元素 可以是 任意类型 。

数组的长度一旦固定，则***不更改***。 

可以通过下标（索引）的方式来 获取（赋值） 数组指定的元素， 这种方式很快。

分类 ： 一维数组 、 N维数组

### 一维数组
#### 声明语法
```text
数据类型[] 变量名 ; 建议使用这种方式

数据类型 变量名[] ; //继承C的语法
```
注意：***在声明变量的时候，不可以声明数组的长度*** 。

#### 初始化
- 动态初始化 ： 数组的声明与 赋值 是分开的。
```text
int[] a;
...
a = new int[10];
...
```
- 静态初始化 ： 数组的声明与具体赋值是在一起的。
```text
int[] a = new int[10];
```

#### 数组中的常用概念
- **元素** ： 数组中的 内容 ，数组通过下标访问元素。
- **下标** ： 通过 非负整数 的索引变量来访问数组中的元素，  
	索引又称下标。下标从0开始，最大的下标是 (数组的长度-1)
- **长度** : 数组的长度在初始化时已经确定，  
	通过 .length 来进行获取

#### 数组的默认初始值
- byte 的默认值是 0
- short 的默认值是 0 
- int 的默认值是 0 
- long 的默认值是 0L
- float 的默认值是 0.0F
- double 的默认值是 0.0 
- char 的默认值是 \u0000
- boolean 的默认值是  false
- 引用数据类型 的默认值是 null 

#### 数组的内存模型
示例：  

```text
int[] ints = new int[2] ; 
```  
![avatar](D:\File\Java\algorithm-practice\img\数组申请.png)  

1. 在 栈中 创建空间，用于 存放变量 ： `int[]` ints ; 
2. new 负责在 堆（heap） 中 创建一个区域 ， 大小由 `int[2]` 这个决定 。
3. 已经在堆中创建了指定的区域，通过 `=` 赋值运算符，将在堆中创建的区域的首地址赋值给变量 `ints`

### N维数组
语法如下：
```text
多(n)维数组 ： type[](*n)[] vars = new type[length](*n)[] ; 
```
注意：在Java中，一般不会超过 2维数组。

## 重点：十大经典排序
  1. 冒泡排序
  2. 选择排序
  3. 插入排序
  4. 希尔排序
  5. 归并排序
  6. 快速排序
  7. 堆排序
  8. 计数排序
  9. 桶排序
  10. 基数排序  
  
唯一的要求：能够手写 
```text
//冒泡
for( int j = 0 , len = ints.length ; j < len - 1 ; j ++ ){
          for( int i = 0  ;i < len - 1 - j  ; i ++ ){
              if( ints[i] < ints[i + 1] ){
                  // 前一个比后一个大， 则交换
                  int temp = ints[i] ;
                  ints[i] = ints[i + 1] ;
                  ints[i + 1] = temp ;
              }
          }
      }
```

## 数组的复制

使用核心API :
```text
System.arraycopy( 原数组 , 原数组的起始位置 , 目标数组 , 目标数组的开始位置 , 个数 ) 
```

## java.util.Arrays
- Arrays.asList( a1..n.. an ) : 将 相同类型的多个参数 封装到 List 中 
- Arrays.binarySearch : 使用 二分搜索算法 来 搜索指定的数组 
- Arrays.compare : 比较两个数组 ，返回值为`0，1，-1`
   * 如果数组等于另一个数组，则返回 0。
   * 如果数组按字典顺序小于另一个数组，则返回小于 0 的值
   * 如果数组按字典顺序大于另一个数组(更多字符)，则返回大于 0 的值。
- Arrays.copyOf  与 Arrays.copyOfRange ：用于复制指定的数组内容以达到扩容的目的
- Arrays.equals : 判断整个数组是否相等（长度，及对应位上的元素）返回`boolean` 
- Arrays.fill : 填充 ,将数组中的元素全部以 固定的值 进行填充
- Arrays.hashCode ： 计算数组的指定的hash值，
- Arrays.sort() : 按照升序进行排序 

## 面向对象编程 （OOP）
- 面向对象程序设计方法是尽可能模拟人类的思维方式，  
    使得软件的开发方法与过程尽可能接近人类认识世界、解决现实问题的方法和过程 
- 面向对象程序的核心是类，面向对象程序设计就是类的成员设计。
### 创建一个类
语法：
```text
[修饰符] class 类名{ 

类体：包含各种成员 

}
```
注意： class 表示编写的是一个 类 ， 修饰符可选；   
类名一般是 大驼峰式命名法。

- 创建类的对象

标准语法：
```text
数据类型 变量名 = [ new 构造方法() ] ; 
```
- 访问对象中的字段和方法
```text
对象名.字段名 
对象名.方法名
```

### this 关键字 (当前对象的代号)
- `this`关键字 指代 当前对象  
`一个储存当前对象的地址的引用变量。`

- this关键字可用来引用当前类的 实例变量 。  谁调用就是谁 
- this关键字可用于调用 当前类中实例方法(隐式)。  
    在实例方法中，可以直接调用 其他的实例方法，而不用书写this关键字 ， 会自动加上， 但建议书写！  
 ```text
class A{
    void a(){   }
    void b(){
        a();   //= this.a();
    }
}
  ```
- this()可以用来调用当前类的 构造函数。 
- this关键字可作为调用实例方法中的 参数传递。 
- this关键字可作为参数在构造函数调用中传递。 
- this关键字可用于从方法返回当前类的实例。

总结  : 
- this 关键字 代表当前对象 .
- this() : 调用 本类中的其他构造方法.

### 内存分析 之 创建对象
```text
class Phone{
    String name = "华为" ; 
}
Phone phone = new Phone() ; 
```

执行 `Phone phone = new Phone() ; ` 时  
1. 先会在 `栈（stack）` 中 声明 `Phone`类型的变量 `phone`  ， 
2. 在`堆（heap）`中开辟空间 [ new 的作用 ] ，  
    为 Phone 类中的`字段（Field）`设置初始值（默认值或指定值）   
    并 执行 `构造方法` 中的代码（构造器中的代码）  
3. 通过 `=` 将 堆中的地址 复制给 `phone` 变量。

 ***static 修饰的内容会被放在 `方法区（Method area）` 中,是在 加载类时 就创建了，不会在创建实例对象时创建*** 

### 方法
基本语法：
```text
[ 修饰符 ] 返回类型 方法名 ( [ 形参列表 ] ){
    // 方法体 
}
```
注意 ： 方法内部不能再次定义方法，可以调用方法。（可以通过内部类达到同样效果 不推荐）  
 返回类型一定要写，有就写对应数据类型，没有就写 `void` 。  
 返回类型可以是 基本数据类型，也可以是引用数据类型。  
 方法的调用过程中，可以 调用 该类中的 字段 与 方法 ；   
 如果在方法中，调用了自身， 此时这个方法被成为 `递归方法`，一定要注意，递归要终止条件。  
 没有则将大量递归导致java栈内存溢出，抛出异常。`栈溢出！=堆溢出`
 

* 方法的返回  `return` 关键字   
 return 表示一个方法的结束 ；  
  当有返回的时候，方法可以被变量所接收。

#### 形参与实参
* 形参 ： 形式参数 ， 在声明方法时， 在 ( `参数列表` ) 中定义的 参数 。  
```text
void a(int A) { }
//A是形参
```  

* 实参 ： 实际参数 ， 调用方法时 向方法直接传入的参数  
```text
int B=0;
a(B);
//B就是实参
```

#### 方法的返回值
1. 利用 return 进行返回 ；形式：`return 数据;` 。 

    * return 表示一个方法的结束   
    * 如果 方法的返回值 是 void ，则 不需要书写 return 。  
    (但可以书写`return;`,提前结束,不能跟数据)   
    
    * 如果方法中存在指定的返回类型，则可以利用 return 关键字 进行将指定的数据类型返回。

2. 方法的返回值 是 void ，则 **不可以** 使用变量接收；  
   方法的返回值不是void ，则 **可以** 使用与 方法相同的返回类型的变量接收 。

3. 不建议在循环中 使用 return来让循环结束。

#### 方法的归属
从 逻辑上看， 方法只能属于 对象 或 类 。
```text
class a{
static void b () { }
void B () { }
}
```
- 类方法： static 修饰的方法 应该是由 类名 来调用  
```text
a.b();
```    

- 实例方法：没有使用 static 修饰的方法 通过对象 来调用。  
```text
a A = new a();
A.B();
```

#### 方法重载
概念：  
**同一个类**中有**两个或两个以上**方法**同名不同参**的方法，称为方法重载

特点：
- 同一个类 ( 继承来的就是你的，继承来的重载规则和自己的方法一样 )
- 同名 ： 方法名相同
- 不同参 ： 参数 个数、顺序、类型  不一样 
- 返回值 与 修饰符 不做要求 。（既需要方法签名的名相同，参数列表一定有差别）  
改 返回值 与 修饰符 的不算重载

#### 可变长参数
参数在 方法调用的时候才完全确定 ；（调用时创建数组形式的参数）  
 而参数的个数，相同类型可以有多个 ，具体由方法调用时的实参数决定。

形式  ：
```text
声明时：(省略点是必须的)
void a ( 数据类型... 形参的名字 )    { }
调用时：
a.(参数1,参数2,参数n);
```

通过 可变长参数 的 toString形式 ， 可以发现，与数组的格式是一样的，那么就可以将可变长参数当成数组来处理。

而数组的长度是由 调用方法传入的实参 个数 来决定的 ， 而实参 可以是 0 个 、1 个 、多个都可以。

由于可变长的特性 可变长参数一定是在 形参的最后一位，  
并且一个方法中，只能存在一个 可变长参数。  
`原因: 难以界定可变长参数的长度`

#### 参数传递机制
在Java 中， 只存在一种 参数传递机制 ： `值传递`。  
即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。  
```text
不管是什么数据类型的变量，本身都是储存与 栈 中的一个数
即使是 调用方法传参 后不通过 方法返回 修改 引用类型的数值
其原理是：修改 堆 中的值，结束后通过 栈 中的值获取被修改的值，自身没有更改
```

- 基本数据类型 : 将实参 基本数据类型变量 的 `数据值` 传递给形参
- 引用数据类型 : 将实参 引用数据类型变量 的 `地址值` 传递给形参 

### 递归的想法
* 递归的标志：   
    **方法内部调用 方法自身。**

* 特殊循环结构
    1. 初始化部分：第一次调用递归方法时传入的实参；
    3. 循环体部分：递归方法的方法体；
    4. 迭代部分：递归方法内部调用 方法自身时 传入的实参的变化；
    2. 循环条件部分：设置递归方法return确定值时的条件；

### 封装
* 概念：  
通过某种手段 , 限制 外部访问 类的 成员（数据） .  
可以通过 公开的方法 （规定的规则）间接的访问 类的成员以达成数据安全.

* 达成方法：  
通过 权限修饰符 可以将 一些内容 封起来 .   
注意:权限修饰符一共有 3个, 但是 访问级别有 4 个 .  
    * 权限修饰符 : `private` ( 私有的 ) , `protected`( 受保护的 ) , `public`( 公开的 )
    * 访问级别 :   
        1. `private` 
        2. `缺省的`( 来自于C++ , C++ 中关键字为default , 在Java 中不存在对应的关键字) 或 `默认的`  
        3. `protected` 
        4. `public`  

* `private` : 修饰的内容只能在 本类中访问 , 只要超过个范围 , 则不允许访问.

* `默认的`(`缺省的`) : 修饰的内容只能在 本类 和 同包 访问

* `protected` : 修饰的内容只能在 本类  同包 和 子类 访问

* `public` : 任意访问.

- 字段 是 在 类中声明的, 同时做为 类的成员而出现 
- 属性 类的数据成员 在有配对的 get方法 或 set方法 后类层面上的概念称呼。
```text
JavaBean 是一种JAVA语言写成的可重用组件
概念：通过完善的封装机制，将 类 规范化。
特点：外界通过预留的接口（既方法）操纵类的属性（既字段）。
```
* 注意： `类属性` 与 `类变量` 的区别 及类属性的多重含义  
    `类变量` 在java中是指有static修饰的成员变量。
    `类属性` 不同的编程语言有不同的定义，如：  
    在C++中，类属性是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的  
    并且有些语言是 不区分static类型 的，所以并不能用static来表示这个属性是否为类属性

### Java 中的 包
* 概念：  
包 可以理解为 文件夹  
* 语法： 
包的关键字 : package  ; 
```text
package java.lang;
``` 
* 而 package 关键字出现的位置 是 java文件中 除了 注释 的第一行! 

* 一般在读 包的时候, 只会说 后边的名   
    如：java.lang 包, 就读作 lang 包 

包的作用:
* 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
* 可以进行访问权限的区分 , 主要是 protected 和 默认的 访问权限.
* 可以将 具有相同结构 或 相同 功能 的类 或 接口 放在一起 , 便于查找.
* 包可以有多级结构 , 像 文件夹一样可以有多级   
  每一级之间采用 `.`( 英文句号 ) 进行分割   
  如果存在多级包结构 , 对应的格式为 : `package 包1.包2.包3.包4` ,  
  例如 : `java.lang.reflect` ;  
  如果存在类名 , 可以通过 包 进行确定是哪一个类   
  例如 : `java.lang.reflect.Method` . 

### import关键字
* 作用： 用来导入一些 不同 包下的 类 或 接口   
* 形式 : `import 包名.类名`  ,  `import 包名.接口名`    

* 如果想要导入一个包下的所有类和接口, 则 需要使用 通配符`*` , 来表示所有  
 但是 一般的情况,如果调用包的数量较少, 则 不会使用 通配符. 

* import  是在 package 之后出现   
 可以有任意多个 import 语句, 但是只能有一个 package 语句. 

### 构造
* 定义：  
构造 又称 构造方法、构造器 （Constructor） 、构造函数 。  
  
* 作用：  
是一个类里用于创建对象的特殊子程序 。

* 构造就是为了 构建一个对象 而存在 。   
    并且 经常接收一些参数，用来为 实例变量（非static 修饰的 字段 ） 赋值 。  
    `类变量在类加载时初始化，一定是一个常量，只能在构造中调用，修改（非final）`

* 基本语法 ：
```text
[修饰符] 类名( [形参] ){ 方法体 }
```
* 无参构造：一个没有任何参数的构造方法。

* 构造方法与普通方法之间的区别 ：
    - 构造方法没有任何返回值 ， 也就是说没有返回类型；  
    普通方法一定存在 返回类型（无为void）  
 
    - 构造方法的名称 是 类名 ， 如果不是类名就会变成一个普通的方法；   
    普通方法的方法名 符合标识符规则即可。

* 构造之间的重载 （与普通方法重载一致）：
    - 所有的构造方法的名字都是 类名 。 —— 同名
    - 构造方法中的 参数的 个数、类型、顺序 不同 。—— 不同参
    - 对修饰符没有任何要求 。

* 默认构造 ： 当创建一个类的时候， 如果没有明确书写构造方法，则 JDK 会自动加上一个 public 修饰 无参构造 。  
```text
一旦书写了任何一种构造方法，那么JDK 就不会再次提供 构造方法了。
所以，在添加自定义的构造方法的时候，一般都需要在提供一个 public 修饰的无参构造。
```

* 注：构造方法本身没有任何返回 , 但是 new + 构造方法 有返回值（`this`） .


### 继承
* 概念：   
  如果一个 类B `继承自`另一个 类A，就把这个B称为 `A的子类` ，而把A称为 `B的父类` 也可以称 'A是B的基类' 。
  
* 基本语法：  
```text
class SubDemo extends Demo {
}
``` 

    
* 继承的效果：  
    可以让 子类 继承 父类中的 所有的 `字段` 和 `方法`   
    Java 中使用 `extends` 来表示继承关系   
    子类可以添加 父类中 没有的东西 

* 注： 效果上可以继承 父类中的所有东西  
但是 能不能访问 由 `访问权限` 决定 .   
```text
            private  default  protected  public
本类           √    |    √   |    √     |   √

本包                |    √   |     √    |   √

非本包子类           |        |     √    |   √

非本包非子类         |        |          |   √
```

* 如果一个类 没有 指定 父类 , 那么 该类的默认父类是 `java.lang.Object` ;  
`java.lang.Object` 类 , 是 所有的类 父类( 直接 或 间接 ) . 

* 在 Java 中 , `不支持 多继承` , 只有`单继承` . 就表示 extends 后边只能存在一个类. 


#### super 关键字
* super 与 this 的区别  
    this 表示 我 , super 表示 父 

* super 关键字 是一个引用变量，用于引用直接父类对象  
    super.XX 可以代表 父类的一些东西(字段，方法) . 

用法 :
- 可以表示父类的 实例对象 . 表示 `父对象`   
注意:有可能是 `直接父级对象` 或 `间接父级对象` . 
- super() ; 表示调用父类的构造方法   
 在 子类中的构造中使用 , 是放在 子类构造中的第一行（隐式）  
  如果没有书写,则JDK 会 `自动添加` 这一行 

### 重写( override )

* 重写的特征 : (同名 同参 同返回 不低访问权)  
    - 仅发生在 `继承` 关系中 
    - 方法名相同 , 参数 相同 ( 参数的个数 类型 顺序 )
    - 返回类型 : 
        - 基本数据类型 : 完全一致 
        - 引用数据类型 : 保证 "同源"
    - 修饰符 : 子类重写方法的修饰符 不能 比 父类方法中的修饰符 要低 ( 访问权限 )  
    `public > protected > private`  
* 基本语法：  
```text
    public static class ab{
        protected void ww(){}
    }
    public static class a extends ab{
        @Override
        public void ww(){}
        //private void ww(){} 编译错误
    }
编码风格要求 标注 重写方法 @Override
```

* 重写( override )与重载( overload )的异同  
    + 重载：发生在一个类中  
      重写：发生在 子类 与 父类 间    
      
    + 重载：参数不同  
      重写：参数相同    
      
    + 重载：访问权限无要求  
      重写：子类 不低于 父类 权限  
      
    + 重载：多个方法并存  
      重写：子类重写方法 覆盖 父类方法   `子类中无父类原方法，父类中无子类重写方法`  
       ```text
          public static class ab{
              public void qq(){
                  System.out.println("父类原方法");
              }
          }
          public static class a extends ab{
              @Override
              public void qq(){
                  System.out.println("子类重写方法");
              }
          }
          public static void main(String[] args){
              ab i =new ab();
              i.qq();     //父类原方法
      
              a j =new a();
              j.qq();     //子类重写方法
      
              ab k=new a();                       //k变量 依就是 a类 对象
              System.out.println(j.getClass());   //class 实验$a
              System.out.println(k.getClass());   //class 实验$a
              k.qq();     //子类重写方法
          }
      ```

### 多态
多态是**同一个行为**具有多个**不同表现形式或形态**的能力。

分类 :
- 运行时多态 :  
 发生的基础 是继承 , 同时 保证 子类重写了 父类 的 方法. 本质是 父类类型的变量 指向 子类对象 
- 编译时多态 :  
 是由 重载 决定的 , 在 .java 文件 编译阶段 表现出 多种形态 

运行时类型与编译时类型 :   
```text
示例类的关系如下：
public abstract class Animal{
	public abstract void eat();
}
class Cat extends Animal{
	public void eat(){
		System.out.println("eat fish");
	}
}
class Dog extends Animal{
	public void eat(){
		System.out.println("eat bones");
	}
    public void squat(){
		System.out.println("not squat");
	}
    public void squat(String food){
		System.out.println("squat");
	}
}
```
- ***运行时多态 :***  
    ```text
    使用父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，可以实现使用一个方法对多种子类对象进行同一个操作
    public static void main(String[] args){
    		Cat cat = new Cat();
    		Dog dog = new Dog();
    		
    		showAnimalEat(cat);
    		showAnimalEat(dog);
    	}
    	
    	/*
        使用Cat和Dog的父类Animal作为方法的参数
        就可以通过只写一个方法而实现调用两类的不同的eat（）方法，去实现同一个功能—————吃。
    	*/
    	public static void showAnimalEat(Animal animal){
    		animal.eat();
    	}
    ```  
- ***编译时多态 :***   
    ```text
    使用改变方法的形式参数，进行重载方法的调用，可以实现使用一个 方法名 对每种不同情况的形参，进行不同的处理
    public static void main(String[] args){
    		Cat cat = new Cat();
  
    		cat.squat();
    		cat.squat("肉干");
    	}
    ``` 

#### instanceof
* 含义 :   
XXX 是 YYY这个类型 吗 ? 返回值是 boolean 类型;   
* 作用：  
判断变量的运行时类型 

* 语法 : 
```text
变量 instanceof 类 
```

* JDK17 的优化方案 : (模式匹配)
```text
if( x instanceof Type  typeVar ) {
    typeVar.method ; 
}
x 是 一个要 判断的 变量 
Type 是具体的类型
typeVar 就是 Type类型的变量 
method 是 Type 类中的方法.
效果：
如果 X 是 Type类型 的 对象 ，则将值 赋给 typeVar，
判断执行部分可用 typeVar变量 代指 X
```

#### 引用强制类型转换的本质
```text
实例类关系
    public static class ab{
        public void qq(){
            System.out.println("父类原方法");
        }
    }
    public static class a extends ab{
        @Override
        public void qq(){
            System.out.println("a子类方法");
        }
    }
    public static class b extends ab{
        @Override
        public void qq(){
            System.out.println("b子类方法");
        }
    }
```
* 基本语法：
```text
 ab i =new a();
 b j = (b) i;
```
* 实质：   
将栈中存放的对象的地址( i 中存放的地址) 赋值给另外一个变量( j ) 并转换成目标类型（b）

* 注意 ：
    + 同源类型强转编译器不报错，但运行时可能无法转换报错中止，具体情况如下：
        ```text
          public static void main(String[] args){
                ab i =new a();
                i.qq();//a子类方法
        
        //      ab j =(ab) i;//编译时没错，但运行时出错
        //      b  j =(b) i;//编译时没错，但运行时出错
        
                a  j =(a) i;//强转成功
                j.qq();//a子类方法
            }
        ```


### static 关键字
* 含义： 
static 表示 静态的 ， 表示 类加载阶段 初始化    

* 作用范围：  
 可以修饰 变量、方法、代码块、内部类（内部接口） 。

* 使用语法：  
```text
class a{
static int A = 9;
}
public static void main(String[] args){
                int B = a.A ;
}
//  static 修饰的内容 是通过  类名.变量（方法） 直接使用
```

- 修饰变量  
 (静态变量， 静态成员变量， 类初始化变量， 类初始化字段，类变量 )    
 一般是 在 类中 直接使用， 表示 该变量 在 类 初始化的时候 就已经初始化好了。(没有指定值，就是默认值)  
 
- 修饰方法   
( 静态方法 )   
 一般是 在类中直接使用， 表示 该方法 在 类 初始化的时候 就已经定义好了。   
 
- 修饰代码块  
 就可以表示 类已经被加载了， 类加载阶段就会执行的代码。  
 `要区别于构造方法，两者执行时机不同`  
 
- 注意：  
    * static修饰的变量，在类加载时会被分配到数据区的方法区。  
    类的实例可共享方法区中的变量。  
    
    * static修饰的方法中不能使用this或super    
    
    * static修饰的方法不能引用非static 修饰的变量,  
    但非static的方法可以引用static修饰的方法
  
  
JDK1.5 引入了 static import ;  (使用率很低) 
 形式 ：`import static java.lang.Math.*;`    
 那么在 使用的时候就可以不用书写类名了:`pow(4.2)`。

### 代码块
代码块与 变量的分类是差不多的。

语法：
```text
[修饰符] { 
此时就是一个代码块了！
}
```

- 成员代码块 (都可以多个，由上至下的顺序一次执行，但一般不会写多个)  
  - 静态代码块（类初始化代码块） 使用 static 修饰的代码块 
  - 实例代码块 ： 没有使用 static 进行修饰的代码块   
    * 实例代码块在构造方法执行之前执行。构造方法执行一次，实例代码块执行一次，  
    `对象构建时机`
- 局部代码块 ： 在 方法内部 直接 声明的代码块  ， 很少使用。

执行顺序
- 一个类中存在 代码块、static代码块、构造方法 的时候  
```text
     static代码块 -> 代码块 -> 构造方法。    
    ↑            ↑  
   类加载      创建对象
```  

  - 当 static 代码块 执行的时候，就可以认为 这个类 已经被加载到 jvm 中了。  
  
### final 关键字
final ： 最后的， 最终的 。

final 可以修饰 变量、 非抽象方法、 非抽象类 。
- final 修饰的变量 不可 ***改变***
- final 修饰的方法 不可 ***重写*** 
- final 修饰的类 不可 ***继承*** 

面试题 ： final 、finally 、 finalize() 有什么异同？   
相同点:名称相似；   
不同点： 是完不同的概念。
```text
final: 属性修饰符，表示 最后的， 最终的。
```
```text
Finally: 语法关键字 一般与try一起使用
在程序进入try块之后,无论程序是因为异常而中止或其它方式返回终止的，finally块的内容一定会 被执行
try { 代码1 }catch ( 出现的异常 ) { 代码2 }finally { System.out.println("出现异常"); }
```
```text
finalize():类似于C++中析构函数
但由于java的自动回收机制，所以不能保证它的被执行次数和被执行时机
我们需要释放：  
    非Java 资源（如打开的文件资源、数据库连接等）
    调用非Java方法（native方法）时分配的内存
时，使用它，但由于它的不确定性
通常的做法是提供 显示的 `close()` 方法 供客户端手动调用。
```

### 密封类

`JDK16 是预览版本，JDK17是确定的版本。 新的语法特性，有待于后期观察 和 后期应用 参看： oop.seal `

* 产生原因：  
java继承中，父类(除final修饰的类)可以随意被子类继承   
 为了限制肆无忌惮的继承， 产生了密封类。     

* 用途：指定自己能被那几个类继承。

* 基本语法：
```text
sealed class 父类名 permits 子类名 { }
(non-sealed || sealed || final) class 子类名 extends 父类名 [permits 子子类名] { }
```
注意： 子类 有如下选择 ：
- final 修饰的类
  ```text
    final 子类 类名 extends 父类{}
  ```
  * 表示 该子类不会再有子类  
  
- 子类声明自己是 密封类（加上 sealed ） ， 随后直接继承父类， 并声明子类
  ```text
  sealed class 类名 extends 父类 permits 子类 {}
  ```
  * 依旧没有打破 密封类限制  
  
- 子类声明自己不再是一个密封类了( 加上 non-sealed )
  ```text
   non-sealed class 类名 extends 父类
  ```
  * 打破密封类限制 可以通过继承它坚决继承被密封的类
### abstract 关键字
1. ***抽象类***  
    * 基本语法：  
        ```text
        abstract class 类名{}
        ```
    * 出现抽象类的原因：  
        1. 不能够明确 一个类 中的具体设计 是什么样的， 可以考虑设置成抽象类   
         
        2. 不能明确一个方法 应该如何实现（方法没有方法体）   
            该方法可以变成 抽象方法 ， 那么拥有抽象方法的类必须 是 抽象类。  
            `抽象类可以做到只有非抽象方法，非抽象类一定没有抽象方法`    
         
        3. 一个类 不想被实例化 就可以设置成抽象类。（只想当父类）  
         
        * 注意：abstract 与 final 不共存 两者与 static 都不冲突  
        ```text
        虽然abstract 与 final 不共存，但不意味abstract 类一定要被继承
        abstract 类可以没有 实现类（子类），只是不能创建实例对象，static变量和方法 可以正常使用
         public static abstract   class ab{
                 static final int A=0;
             }
            public static void main(String[] args){
                int B=ab.A;
                System.out.println(B);
            }
        ```  
         
    * 抽象类 仅仅不可以实例化，其他的内容与其他的类没有任何区别。
    * 抽象类中存在构造， 仅供 子类调用。
    * 抽象类中可以有抽象方法，也可以有非抽象方法 。

2. ***抽象方法***  
* 基础语法  
```text
[修饰符] abstract 返回类型 方法名() ; 
```
* 意义：通过创建 子类的实例 来获取 抽象类的 ‘实例’ 。
```text
abstract  class ab{
    abstract void a();
}
class a extends ab{
    @Override
    public void a(){
        System.out.println("a");
    }
}
public class 测试 {
    public static void main(String[] args){
        ab B=new a();
        B.a();
    }
}
```

常用的获取 抽象类'实例' 的 方式 ：
- 抽象类中的 static 修饰的方法
- 抽象类子类中的 static 修饰的方法
- new 抽象类的子类 

### 抽象类的应用( Number类 与 包装类 )
#### Number类

* Number 是 数值类型 的 父类 ，它是一个 `抽象类` 。  
`数值类型指代的是 基本数据类型 对应的Java中的 引用数据 类型。`

Number的方法：
    - xxxValue(); : 可以将 Number 中的数值 转成 对应的XXX 类型； 
    ` xxx 类型是 ： byte、short、int、long、float、double`

#### 包装类
* 定义：基本数据类型都有其对应的引用数据类型，而这些引用数据类型被称为 包装类（Wrapper Class）。

* 对应的包装类如下：
```text
  byte    -> Byte    |  float   -> Float

  short   -> Short   |  double  -> Double

  int     -> Integer |  char    -> Character

  long    -> Long    |  boolean -> Boolean 
```
    

* 自动装箱与拆箱 ：
    - 自动装箱 ： 基本数据类型可以自动封装成对应的引用数据类型    
    `本质还是通过 valueOf 来进行包装的（JVM来完成的）`  
    没有自动装箱的时候，需要通过自主调用 valueOf()进行包装。  
    
    - 自动拆箱 ： 基本数据类型的引用类型可以自动变成其对应的基本数据类型 

##### 通用方法
- valueOf ： 该方法是 一个 static 修饰的方法 ， 该方法可以将 对应的基本数据类型 和 字符串 包装成对应的 引用数据类型 

- toString ： 将一个 引用数据类型转成一个 字符串   

- parseXXXX ： 除了Character 都存在该方法， 该方法可以将 字符串转换成 对应的基本数据类型 

##### 常用方法
Byte , Short , Integer , Long 其中内部都有缓存（内部已经定义好的数组并已经赋值了）  
`具体缓存数值为： -128 ~ 127 之间`  
`Integer 可以通过 配置文件 来修改默认的 缓存 范围`  
* 所以在 缓存范围内 执行 两个数据包装类的对象 比较时可以用`==`获得 值的比较情况  
```text
public static void main(String[] args){
        Integer a=3;
        Integer A=3;
        System.out.println(a==A);//true
        A=5;
        System.out.println(a==A);//flase
        a=128;
        A=128;
        System.out.println(a==A);//flase
    }
//编程器会提出警告，但仍可运行
```
###### Byte
Byte 是 byte 对应的包装类 。常用字段 ：
- MAX_VALUE ： 最大值
- MIN_VALUE : 最小值
- TYPE ： 获取其 Class 类型 

Byte 中的常用方法：
- compare(byte x, byte y) ： 比较大小 ； 
- compareTo( Byte another ) : 内部调用了 compare()
- XXXValue ： 其实就是Byte 内部有一个 字段：value ， 每次调用 XXXValue 的时候，其实就是返回 value ， 有时可能对其进行操作。

###### Short
Short 是 short 对应的包装类， 常用字段：
- MAX_VALUE ： 最大值
- MIN_VALUE : 最小值
- TYPE ： 获取其 Class 类型 

Short 中的常用方法：
- compare(short x, short y) ： 比较大小 ；
- compareTo( Short another ) : 内部调用了 compare()
- XXXValue ： 其实就是Short 内部有一个 字段：value ， 每次调用 XXXValue 的时候，其实就是返回 value ， 有时可能对其进行操作。

###### Integer
Integer 是 int 对应的包装类， 常用字段：
- MAX_VALUE ： 最大值
- MIN_VALUE : 最小值
- TYPE ： 获取其 Class 类型

Integer 中的常用方法：
- compare(int x, int y) ： (x < y) ? -1 : ((x == y) ? 0 : 1);
- compareTo( Integer another ) : 内部调用了 compare 方法
- XXXValue ： 其实就是Integer 内部有一个 字段：value ， 每次调用 XXXValue 的时候，其实就是返回 value ， 有时可能对其进行操作。
- max 、min( a , b )  : 这两个都是 Integer 内部的方法， 主要是获取 最大值 或 最小值
- sum( a , b ) : 求和 
- toBinaryString() 、toHexString 、 toOctalString ： 返回 二进制 、 十六进制 、 八进制 的 字符串 

###### Long
Long 是 long 对应的包装类， 常用字段：
- MAX_VALUE ： 最大值
- MIN_VALUE : 最小值
- TYPE ： 获取其 Class 类型

Long 中的常用方法：
- compare(short x, short y) ： (x < y) ? -1 : ((x == y) ? 0 : 1); 
- compareTo( Long another ) : 内部调用了 compare 方法
- XXXValue ： 其实就是 Long 内部有一个 字段：value ， 每次调用 XXXValue 的时候，其实就是返回 value ， 有时可能对其进行操作。
- max 、min( a , b )  : 这两个都是 Integer 内部的方法， 主要是获取 最大值 或 最小值
- sum( a , b ) : 求和
- toBinaryString() 、toHexString 、 toOctalString ： 返回 二进制 、 十六进制 、 八进制 的 字符串 

###### Float
Float 是 float 对应的包装类， 常用字段：
- MAX_EXPONENT ： 最大 的 指数
- MIN_EXPONENT ： 最小 的指数
- MAX_VALUE ： 最大值
- MIN_VALUE ： 最小值
- NaN ： 非数字值  0.0f/0.0f
- NEGATIVE_INFINITY ： 负无穷  -1.0f/ 0.0f 
- POSITIVE_INFINITY ： 正无穷  1.0f / 0.0f 
- TYPE ： 获取其 Class 类型

常用方法：
- compare(float x, float y) ： 正常使用 判断即可， 但是 有可能传入 Float 类型的 特殊值（NaN ， NEGATIVE_INFINITY ， POSITIVE_INFINITY） ， 所以判断更加复杂
- compareTo( Float another ) : 内部调用了 compare 方法
- XXXValue ： 其实就是 Float 内部有一个 字段：value ， 每次调用 XXXValue 的时候，其实就是返回 value ， 有时可能对其进行操作。
- max 、min( a , b )  : 这两个都是 Integer 内部的方法， 主要是获取 最大值 或 最小值
- sum( a , b ) : 求和
- toHexString : 将 float 的值变成一个 16 进制的 字符串
- isFinite(float f) ： 是否是有限
- isInfinite() ： 是否是无限的对象 ： floatObject.isInfinite
- isInfinite(float v) : 是否是无限的数值
- isNaN() ： 是否 不是一个数字  . 如果对象是 NaN ， 则返回true
- isNaN(float v) ： 是否 不是一个数字 

###### Double
Double 是 double 对应的包装类， 常用字段：
- MAX_EXPONENT ： 最大 的 指数
- MIN_EXPONENT ： 最小 的指数
- MAX_VALUE ： 最大值
- MIN_VALUE ： 最小值
- NaN ： 非数字值  0.0f/0.0f
- NEGATIVE_INFINITY ： 负无穷  -1.0f/ 0.0f
- POSITIVE_INFINITY ： 正无穷  1.0f / 0.0f
- TYPE ： 获取其 Class 类型

常用方法：
- compare(double x, double y) ： 正常使用 判断即可， 但是 有可能传入 Double 类型的 特殊值（NaN ， NEGATIVE_INFINITY ， POSITIVE_INFINITY） ， 所以判断更加复杂
- compareTo( Double another ) : 内部调用了 compare 方法
- XXXValue ： 其实就是 Double 内部有一个 字段：value ， 每次调用 XXXValue 的时候，其实就是返回 value ， 有时可能对其进行操作。
- max 、min( a , b )  : 这两个都是 Integer 内部的方法， 主要是获取 最大值 或 最小值
- sum( a , b ) : 求和
- toHexString : 将 float 的值变成一个 16 进制的 字符串
- isFinite(f) ： 是否是有限
- isInfinite() ： 是否是无限的对象 ： floatObject.isInfinite
- isInfinite(v) : 是否是无限的数值
- isNaN() ： 是否 不是一个数字  . 如果对象是 NaN ， 则返回true
- isNaN(v) ： 是否 不是一个数字 

###### Boolean
Boolean 是 boolean 对应的包装类， 常用字段：
- TYPE ： 获取其 Class 类型
- TRUE : ture
- FALSE :  false 


常用方法：
- booleanValue() ： 从 Boolean 中 获取到 boolean 的值 , 其中依旧有一个 value 字段来存放
- compare( boolean x , boolean y ) : (x == y) ? 0 : (x ? 1 : -1);
- compareTo( Boolean another ) : 调用了 compare 

###### Character
代码点( code point ) : Unicode是属于编码字符集（CCS）的范围。Unicode所做的事情就是将我们需要表示的字符表中的每个字符映射成一个数字，这个数字被称为相应字符的码点（code point）

常用方法：
- compareTo(Character anotherCharacter)  调用 compare 方法
- compare(char x, char y) : x - y; 
- isLetter(char ch) ： 是否是一个字母
- isLowerCase(char ch) ： 是否是小写
- isUpperCase(char ch) ： 是否是 大写
- isWhitespace(char ch) ： 是否是空格
- toLowerCase(char ch) ： 变小写
- toUpperCase(char ch) ： 变大写

#### 数字格式化 NumberFormat
* 意义：数字格式化的目的统一数字格式， 以便于后续的使用。

* NumberFormat 是所有数字格式化类的抽象基类。

* 获取 NumberFormat ‘实例’  
    `与其他抽象类使用方法相同`
    1. 使用 NumberFormat 中的 static 修饰的方法 （ 可以使用， 但是局限性比较大 ）
       * getCompactNumberInstance() ： 返回具有“SHORT”格式样式的默认 FORMAT 语言环境的紧凑数字格式
       * getCompactNumberInstance(Locale locale, NumberFormat.Style formatStyle) ： 返回指定区域设置和 formatStyle 的紧凑数字格式
       * getCurrencyInstance() ： 返回当前默认 FORMAT 语言环境的货币格式。
       * getCurrencyInstance(Locale inLocale) ： 返回指定区域设置的货币格式。
       * getInstance() : 返回当前默认 FORMAT 语言环境的通用数字格式。
       * getInstance(Locale inLocale) : 返回指定语言环境的通用数字格式
       * getIntegerInstance() : 返回当前默认 FORMAT 语言环境的整数格式
       * getIntegerInstance(Locale inLocale) : 返回指定语言环境的整数格式
       * getNumberInstance() : 返回当前默认 FORMAT 语言环境的通用数字格式。
       * getNumberInstance(Locale inLocale) : 返回指定语言环境的通用数字格式。
       * getPercentInstance() : 返回当前默认 FORMAT 语言环境的百分比格式。
       * getPercentInstance(Locale inLocale) : 返回指定区域设置的百分比格式
    2. 使用  NumberFormat 的子类中的 static 修饰的方法
    3. 创建 NumberFormat 的子类对象 。
       1. 创建 DecimalFormat 子类对象来进行格式化或解析  ， 更为简单的操作。
    
* 格式化与解析的区别  

    格式化（format） ： 将 指定的数字 转换成 具有特定格式的 字符串 
    ```text
            //当前日期时间，没有时区
            LocalDateTime now = LocalDateTime.now();
            //日期格式化，通用时间表达式
            DateTimeFormatter fmt = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");
            //2022-3-13 08:08:24
            String nowStr = fmt.print(now);
    ```
    解析 （parse）： 将 特定格式的字符串 解析成 具体的数字 
     ```text
              String dateStr = "2022-03-13 08:08:24";
              //根据时间表达式生成DateTimeFormatter对象
              DateTimeFormatter fmt = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");
              //2022-03-13T08:08:24.000+08:00
              DateTime dateTime = fmt.parseDateTime(dateStr);
 
### 内部类
* 概念 ：   
    写在 一个类 或 一个方法 内部 的 类    
    
* 别名：嵌套类 [Nested Classes] 

* 语法：和正常类语法大体相同
```text
内部类语法：
public class 外部类 {
...外部类结构代码...
class 内部类 { 内部类结构代码 }
...外部类结构代码...
}
匿名类语法：
类名 a = new 类名() { 内部类结构代码 };
//注意匿名类后有’；‘号
```

* 划分：
    - 成员内部类
      - static 修饰的内部类 （类初始化内部类、静态内部类）   
      `创建实例方式： new 外部类.内部类名() ;` 
      - 没有static 修饰的内部类 （实例内部类、对象内部类）   
      `创建实例方法 ： 外部类的对象.new 内部类名() ;`
    - 局部内部类
      - 在 方法中进行声明的内部类 
      - 特殊形式 ： 匿名内部类 （多用于快速实现抽象类（或接口）的子类）   
      `匿名类的语法就类似于调用一个类的构建函数`

* 注意：
     所有的内部类都有对应的 .class 文件   

     对于静态内部类、实例内部类来说，他们对应的 .class 的名称是：   
    `外部类类名$内部类类名.class`  
    
     局部内部类（有名称的）来说：他们对应的 .class 文件名称是：  
    外部类类名$Number 内部类类名.class`
     - 其中的 Number 是 使用 该名称 的 内部类 在 外部类 出现的位置（第几个）   
     
     有一个局部内部类 没有名字 它就是匿名内部类，但是它 ***有*** 对应的.class 文件   
    匿名内部类对应的.class 文件名 是 `外部类类名$数字.class`
     - 常用的场景 ：
       - 用匿名内部类实现接口
       - 用匿名内部类继承抽象类 
       - 用匿名内部类继承普通的类

* Lambda 类  
    * 本质上是一个 `匿名内部类` 。但作为一个新的 `语法糖` 来实现。  
    * 主要用途:  
    是简化某些 `匿名内部类（Anonymous Classes）` 的写法

* Lambda表达式：  
    + 在Java8中引入一种新的语法元素和操作符 `->`   
    该操作符被称为 `Lambda操作符` 或 `箭头操作符`  
        它将Lambda分为两部分：  
        - 左侧：指定了Lambda表达式需要的参数列表 （其实就是抽象方法的形参列表）
        - 右侧：指定了Lambda体，是抽象方法的实际逻辑，也就是Lambda表达式要执行的功能。（重写抽象方法的方法体）  
    + 例子：  
```text
待实现接口：
interface  ab{
   abstract int ADD(int a,int b);
}

传统匿名内部类写法：
        public static void main(String[] args){
          ab a = new ab() {
          @Override
          public int ADD(int a , int b){
          return a+b;
          }
          }; 
         System.out.println(a.ADD(1,3));//4
        }

Lambda表达式写法：
        public static void main(String[] args){
            ab A =(int a,int b) ->{
                return a+b;
            };
            System.out.println(A.ADD(1,3));//4
        }
//Lambda表达式只能用于实现接口`实例`
//可以省略参数表的类型，是借助了javac的类型推断机制，编译器能够根据上下文信息推断出参数的类型，推断失败时需要手动指明参数类型
//在没有模式匹配的java版本中最好带参数类型
```


